{"task_id": "01", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef grover_search_oracle_00() ->QuantumCircuit:\n    \"\"\"\n        Implement a quantum circuit using grover algorithm to find oracle |00> using qiskit, return the QuantumCircuit after measuring.\n    \"\"\"", "entry_point": "grover_search_oracle_00", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef grover_search_oracle_00() ->QuantumCircuit:\n    \n    qr = QuantumRegister(2, 'q')\n    cr = ClassicalRegister(2, 'c')\n    qc = QuantumCircuit(qr, cr)\n\n    qc.h([0, 1])\n    qc.x([0, 1])\n    qc.cz(0, 1)\n    qc.x([0, 1])\n    qc.h([0, 1])\n    qc.z([0, 1])\n    qc.cz(0, 1)\n    qc.x([0, 1])\n    qc.h([0, 1])\n        \n    qc.measure([0, 1], [0, 1])\n   \n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        result = run_circuit(self.generated_circuit)\n        most_common = max(result, key=result.get)\n        self.assertEqual(most_common,\"00\")"}
{"task_id": "02", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef generate_quantum_state_qubit3() ->QuantumCircuit: \n\n        \"\"\"\n                Implementation a quantum circuit to create the state ψ = √(1/2)(|011⟩ − |100⟩) using qiskit, return the QuantumCircuit after measuring.\n        \"\"\"", "entry_point": "generate_quantum_state_qubit3", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\ndef generate_quantum_state_qubit3() -> QuantumCircuit:\n    qc = QuantumCircuit(3,3)   \n    qc.h(2)     \n    qc.x(1)     \n    qc.cx(2,1)  \n    qc.cx(1,0)\n    qc.z(2) \n    qc.measure([0,1,2], [0,1,2])\n    \n    return qc", "test": "import unittest\nimport numpy as np\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        phase = check_phase(self.generated_circuit,\"100\")\n        self.assertAlmostEqual(phase, np.pi, delta=0.1)\n        result = run_circuit(self.generated_circuit)\n        self.assertTrue(result.keys() == {\"011\",\"100\"})\n        self.assertAlmostEqual(result[\"011\"], result[\"100\"], delta=500)"}
{"task_id": "03", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef grover_3SAT() ->QuantumCircuit: \n\n        \"\"\"\n                Implement a quantum circuit using grover algorithm to solve the 3 SAT problem with 3-CNF formula {((x1) | (x2) | (x3))\n                & ((_not(x1)) | (x2) | (x3))\n                & ((_not(x1)) | (_not(x2)) | (_not(x3)))\n                & ((_not(x1)) | (_not(x2)) | (x3))\n                & ((x1) | (x2) | (_not(x3)))\n                & ((_not(x1)) | (x2) | (_not(x3)))} using qiskit, return the QuantumCircuit after measuring.\n        \"\"\"", "entry_point": "grover_3SAT", "canonical_solution": "from qiskit.circuit.library import PhaseOracle\nfrom qiskit_algorithms import Grover, AmplificationProblem\nfrom qiskit.primitives import Sampler\n\ndef grover_3SAT():\n    \"\"\"\n    Solve 3-SAT problem using Grover's Algorithm (compatible with new Qiskit version).\n    Formula:\n    ((x1) ∨ (x2) ∨ (x3)) ∧\n    (¬x1 ∨ x2 ∨ x3) ∧\n    (¬x1 ∨ ¬x2 ∨ ¬x3) ∧\n    (¬x1 ∨ ¬x2 ∨ x3) ∧\n    (x1 ∨ x2 ∨ ¬x3) ∧\n    (¬x1 ∨ x2 ∨ ¬x3)\n    \"\"\"\n    expression = \"(x1 | x2 | x3)&(~x1 | x2 | x3)&(~x1 | ~x2 | ~x3)&(~x1 | ~x2 | x3)&(x1 | x2 | ~x3)&(~x1 | x2 | ~x3)\"\n    \n    oracle = PhaseOracle(expression)\n    problem = AmplificationProblem(oracle=oracle)\n    grover = Grover(sampler=Sampler(options={\"shots\": 10000}))\n    result = grover.amplify(problem)\n\n    return result.circuit_results[0]", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_result = cir_solution()\n        self.oracle_result = {key: value * 10000 for key, value in self.oracle_result.items()}\n        self.generated_circuit = cir_generated()\n        self.generated_result = run_circuit(self.generated_circuit)\n    def test_functional_equality(self):\n        KL = compute_KL_noexecute(self.oracle_result, self.generated_result)\n        self.assertTrue(0<=KL<0.1)\n\n    def test_statical_assert(self):\n        generated_top2 = sorted(self.generated_result.items(), key=lambda x: x[1], reverse=True)[:2]\n        generated_top2_values = [v for k, v in generated_top2]\n        generated_top2_keys = [k for k, v in generated_top2]\n        self.assertEqual(generated_top2_keys, [\"010\", \"110\"])\n        self.assertAlmostEqual(generated_top2_values[0],generated_top2_values[1], delta=200)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "04", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef qaoa_maxcut_ansatz(G, beta, gamma) ->QuantumCircuit: \n\n        \"\"\"\n                Implement a quantum circuit using QAOA algorithm to solve the maxcut problem with the graph ([[0,3],[0,4],[1,3],[1,4],[2,3],[2,4]]), return the QuantumCircuit after measuring.\n                 Parameters:\n                        G (networkx.Graph): The input graph for MaxCut.\n                        beta (List[float]): A list of 5 parameters for the mixing unitaries (RX rotations).\n                        gamma (List[float]): A list of 5 parameters for the cost unitaries (ZZ rotations).\n                        \n        \"\"\"", "entry_point": "qaoa_maxcut_ansatz", "canonical_solution": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\ndef qaoa_maxcut_ansatz(G, beta, gamma) -> QuantumCircuit:\n    \n    n = len(G.nodes)\n    p = len(beta)\n    \n    qr = QuantumRegister(n, 'q')\n    cr = ClassicalRegister(n, 'c')\n    qc = QuantumCircuit(qr, cr)\n    qc.h(qr)\n    for i in range(p):\n        \n        for u, v in G.edges:\n            qc.cx(qr[u], qr[v])\n            qc.rz(2 * gamma[i], qr[v])\n            qc.cx(qr[u], qr[v])\n        \n        \n        for qubit in range(n):\n            qc.rx(2 * beta[i], qr[qubit])\n    \n    \n    qc.measure(qr, cr)\n    \n    return qc", "test": "import unittest\nimport unittest\nimport numpy as np\nimport networkx as nx\nfrom scipy.optimize import minimize\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer\ndef qaoa_execute(qaoa_maxcut):\n    G = nx.Graph()\n    G.add_edges_from([[0,3],[0,4],[1,3],[1,4],[2,3],[2,4]])\n\n    def invert_counts(counts):\n        return {k[::-1]:v for k, v in counts.items()}\n\n    backend = Aer.get_backend('qasm_simulator')\n\n    def get_qaoa_circuit(G, beta, gamma):\n        return qaoa_maxcut(G, beta, gamma)\n\n    def maxcut_obj(x,G):\n        cut = 0\n        for i, j in G.edges():\n            if x[i] != x[j]:\n                # the edge is cut\n                cut -= 1\n        return cut\n\n    def compute_maxcut_energy(counts, G):\n        energy = 0\n        total_counts = 0\n        for meas, meas_count in counts.items():\n            obj_for_meas = maxcut_obj(meas, G)\n            energy += obj_for_meas * meas_count\n            total_counts += meas_count\n        return energy / total_counts\n\n    def get_black_box_objective(G,p):\n        backend = Aer.get_backend('qasm_simulator')\n        def f(theta):\n            # let's assume first half is betas, second half is gammas\n            beta = theta[:p]\n            gamma = theta[p:]\n            #qc = get_qaoa_circuit(G,beta, gamma)\n            qc = get_qaoa_circuit(G, beta, gamma)\n            counts = execute(qc, backend, seed_simulator=10, shots=10000).result().get_counts()\n            # return the energy\n            return compute_maxcut_energy(invert_counts(counts), G)\n        return f\n\n\n    def append_zz_term(qc, q1, q2, gamma):\n        qc.cx(q1,q2)\n        qc.rz(2*gamma, q2)\n        qc.cx(q1,q2)\n\n    def get_cost_operator_circuit(G, gamma):\n        N = G.number_of_nodes()\n        qc = QuantumCircuit(N,N)\n        for i, j in G.edges():\n            append_zz_term(qc, i, j, gamma)\n        return qc\n        \n    def append_x_term(qc, q1, beta):\n        qc.rx(2*beta, q1)\n\n    def get_mixer_operator_circuit(G, beta):\n        N = G.number_of_nodes()\n        qc = QuantumCircuit(N,N)\n        for n in G.nodes():\n            append_x_term(qc, n, beta)\n        return qc\n\n    p = 5\n    obj = get_black_box_objective(G, p)\n\n    init_point = np.array([0.81069872, 2.2067517 , 0.83830696, 2.15579759, 0.37060699,\n        2.42068091, 6.1575306 , 2.2453419 , 3.85060091, 6.137845  ])\n    # We are going to limit the number of iterations to 2500\n    res_sample = minimize(obj, init_point, method='COBYLA', options={'maxiter':2500, 'disp': True})\n\n    optimal_theta = res_sample['x']\n    qc = get_qaoa_circuit(G, optimal_theta[:p], optimal_theta[p:])\n    counts = invert_counts(execute(qc, backend).result().get_counts())\n    return counts\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = qaoa_execute(cir_solution)\n        self.generated_circuit = qaoa_execute(cir_generated)\n\n    def test_functional_equality(self):\n        KL = compute_KL_noexecute(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "05", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef qaoa_knapsack() ->QuantumCircuit: \n\n        \"\"\"\n                Implement a quantum circuit using QAOA algorithm to solve the knapsack problem represented items_value=[3, 3, 1, 1, 5], items_weight = [2, 4, 1, 3, 5], maxium_weight = 7. Return the QuantumCircuit after measuring.\n        \"\"\"", "entry_point": "qaoa_knapsack", "canonical_solution": "from qiskit_optimization.algorithms import MinimumEigenOptimizer\nfrom qiskit_optimization.applications import Knapsack\nfrom qiskit.primitives import Sampler\nfrom qiskit_aer import Aer\nfrom qiskit.utils import algorithm_globals, QuantumInstance\nfrom qiskit_algorithms.optimizers import COBYLA\nfrom qiskit_algorithms import QAOA, NumPyMinimumEigensolver\nimport numpy as np\n\ndef qaoa_knapsack(): \n    val=[3, 3, 1, 1, 5]\n    wt = [2, 4, 1, 3, 5]\n    W = 7\n\n    def dp(W, wt, val, n):\n        k = [[0 for x in range(W + 1)] for x in range(n + 1)]\n        for i in range(n + 1):\n            for w in range(W + 1):\n                if i == 0 or w == 0:\n                    k[i][w] = 0\n                elif wt[i-1] <= w:\n                    k[i][w] = max(val[i-1] + k[i-1][w-wt[i-1]], k[i-1][w])\n                else:\n                    k[i][w] = k[i-1][w]\n                    \n        picks=[0 for x in range(n)]\n        volume=W\n        for i in range(n,-1,-1):\n            if (k[i][volume]>k[i-1][volume]):\n                picks[i-1]=1\n                volume -= wt[i-1]\n        return k[n][W],picks\n\n    n = len(val)\n    print(\"optimal value:\", dp(W, wt, val, n)[0])\n    print('\\n index of the chosen items:')\n    for i in range(n): \n        if dp(W, wt, val, n)[1][i]: \n            print(i,end=' ')\n\n    def knapsack_quadratic_program():\n        prob = Knapsack(values = val, weights = wt, max_weight=W)\n        kqp = prob.to_quadratic_program()\n        return prob, kqp\n\n    prob,quadratic_program=knapsack_quadratic_program()\n    quadratic_program\n\n    meo = MinimumEigenOptimizer(min_eigen_solver=NumPyMinimumEigensolver())\n    result = meo.solve(quadratic_program)\n    print('result:\\n', result)\n    print('\\n index of the chosen items:', prob.interpret(result)) \n\n    # QAOA\n    optimizer = COBYLA(maxiter=100)\n    qaoa_solver = QAOA(sampler=Sampler(options={\"shots\": 1000}),optimizer=optimizer)\n    meo = MinimumEigenOptimizer(min_eigen_solver=qaoa_solver)\n    result = meo.solve(quadratic_program)", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.generated_circuit = cir_generated()\n        self.generated_result = run_circuit(self.generated_circuit)\n    def test_functional_equality(self):\n        pass\n\n    def test_statical_assert(self):\n        generated_top1 = sorted(self.generated_result.items(), key=lambda x: x[1], reverse=True)[:1]\n        generated_top1_value = [k for k, v in generated_top1]\n        self.assertEqual(generated_top1_value[0], \"1001\")\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "06", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef swaptest_zaxis(unknown_state: QuantumCircuit) ->QuantumCircuit: \n\n    \"\"\"\n            Implement a quantum circuit using the SWAP test algorithm to estimate the angle θ (in radians) between an unknown single-qubit quantum state and the |0⟩ state (Z-axis).\n            The input is a single qubit QuantumCircuit unknown_state, and returns a QuantumCircuit after measuring the ancilla qubit\n    \"\"\"", "entry_point": "swaptest_zaxis", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef swaptest_zaxis(unknown_state: QuantumCircuit) ->QuantumCircuit: \n\n    qr = QuantumRegister(3, 'q')  \n    cr = ClassicalRegister(1, 'c') \n    qc = QuantumCircuit(qr, cr)\n    \n    qc = qc.compose(unknown_state, [qr[1]])  \n    qc.h(qr[0])\n    qc.cswap(qr[0], qr[1], qr[2]) \n    qc.h(qr[0])\n    qc.measure(qr[0], cr[0])\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(1)\nqc.h(0)\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution(qc)\n        self.generated_circuit = cir_generated(qc)\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":2,\"cswap\":1}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "07", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef swaptest_individual() ->QuantumCircuit: \n    \n    \"\"\"\n        Implement a quantum circuit using the SWAP test with individual ancilla qubits for each qubit-to-qubit comparison between two 3-qubit quantum states: |011⟩ and |000⟩.\n        Encode |011⟩ on the first set of 3 qubits, and |000⟩ on the second set of 3 qubits. Use 3 ancilla qubits and measure ancilla qubits.\n    \"\"\"", "entry_point": "swaptest_individual", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef swaptest_individual() ->QuantumCircuit: \n    qr = QuantumRegister(9, 'q')\n    cr = ClassicalRegister(3, 'c')\n    qc = QuantumCircuit(qr, cr)\n\n    qc.x(qr[1])\n    qc.x(qr[2])\n    \n    qc.h(qr[6])\n    qc.h(qr[7])\n    qc.h(qr[8])\n    qc.cswap(qr[6],qr[0], qr[3])\n    qc.cswap(qr[7],qr[1], qr[4])\n    qc.cswap(qr[8], qr[2], qr[5])\n    qc.h(qr[7])\n    qc.h(qr[6])\n    qc.h(qr[8])\n    qc.measure(qr[6], cr[0])\n    qc.measure(qr[7], cr[1])\n    qc.measure(qr[8], cr[2])\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":6,\"cswap\":3}.items()), dict(self.generated_circuit.count_ops().items())))\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "08", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom math import pi\n\ndef qft_6() ->QuantumCircuit: \n\n    \"\"\"\n        Implement a 6 qubit quantum fourier transform circuit, and return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "qft_6", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom math import pi\n\ndef qft_6():\n    \"\"\"QFT on 6 qubits\"\"\"\n    qr = QuantumRegister(6, 'q')\n    cr = ClassicalRegister(6, 'c')\n    qc = QuantumCircuit(qr,cr)\n    for i in range(5, -1, -1):\n        qc.h(qr[i])\n        for j in range(i):\n            qc.cp(pi/2**(i-j), qr[j], qr[i])\n    \n    for j in range(3): \n        qc.swap(qr[j], qr[5-j])\n\n    qc.measure(qr, cr)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(6,6)\nqc.h([0,1,2,3,4,5])\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n    def test_functional_equality(self):\n        oracle_test = self.oracle_circuit.compose(qc,qubits=[0,1,2,3,4,5],front=True)\n        generated_test = self.generated_circuit.compose(qc,qubits=[0,1,2,3,4,5],front=True)\n        KL = compute_KL(oracle_test, generated_test)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"cp\":15}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "09", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef qpe_x_gate() ->QuantumCircuit: \n    \n    \"\"\"\n        Implement a quantum circuit to perform Quantum Phase Estimation using 3 counting qubits and 1 target qubit to estimate the phase of a unitary operator X (Pauli-X gate).\n        Return a QuantumCircuit and measure the counting qubits.\n    \"\"\"", "entry_point": "qpe_x_gate", "canonical_solution": "from qiskit import QuantumCircuit\nfrom qiskit.circuit.library import QFT\n\ndef qpe_x_gate(n_count=3):\n    qc = QuantumCircuit(n_count + 1, n_count)\n    qc.h(range(n_count))\n    qc.x(n_count)\n\n    for qubit in range(n_count):\n        repetitions = 2**qubit\n        for _ in range(repetitions):\n            qc.cx(qubit, n_count) \n\n    qc.append(QFT(n_count, inverse=True, do_swaps=True).to_gate(), range(n_count))\n\n    qc.measure(range(n_count), range(n_count))\n\n    return qc\n\nprint(qpe_x_gate())", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        qc = self.generated_circuit.copy()\n        self.assertTrue(set({\"h\":3,\"cx\":7}.items())).issubset(set(qc.count_ops().items()))\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"100\",\"000\"})\n        self.assertAlmostEqual(generated_result[\"100\"], generated_result[\"000\"], delta=500)"}
{"task_id": "10", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\nfrom qiskit.quantum_info import Statevector\nfrom scipy.linalg import expm\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.circuit.library import QFT\nfrom qiskit.circuit.library import RYGate\nimport math\n\ndef HHL_4x4() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit that uses the Harrow-Hassidim-Lloyd (HHL) algorithm to solve a linear system Ax = b,\n        where:\n\n            A = (1/2) * np.array([[3, 0, 0, -1],\n                                [0, 7, -1, 0],\n                                [0, -1, 7, 0],\n                                [-1, 0, 0, 3]])\n\n            b = np.array([1/√2, 1/√2, 0, 0])  # A normalized 4-dim vector\n            t = π/4                            # Evolution time\n            The clock register uses 3 qubits.\n        Return a QuantumCircuit afer measure the solution x.\n    \"\"\"", "entry_point": "HHL_4x4", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\nfrom qiskit.quantum_info import Statevector\nfrom scipy.linalg import expm\nfrom qiskit.circuit.library import UnitaryGate\nfrom qiskit.circuit.library import QFT\nfrom qiskit.circuit.library import RYGate\nimport math\n\ndef HHL_4x4() ->QuantumCircuit: \n    Stateprep = QuantumCircuit(2, name = \"State Prep\")\n    Stateprep.h(0)\n    psi  = Statevector(Stateprep)\n    clock = QuantumRegister(3, name='clock')\n    b = QuantumRegister(2, name='b')\n    ancilla = QuantumRegister(1, name='ancilla')\n    classica_ancialla = ClassicalRegister(1, name = \"anciall classical\")\n    classica_results = ClassicalRegister(2, name = \"result classical\")\n    circuit = QuantumCircuit(ancilla, clock, b, classica_ancialla, classica_results)\n    circuit.append(Stateprep, b)\n    circuit.h(clock)\n    A = (1/2) * np.array([\n        [3,   0,   0,  -1],\n        [0,   7,  -1,   0],\n        [0,  -1,   7,   0],\n        [-1,  0,   0,   3]\n    ]) \n    t = np.pi / 4\n    for idx,c in enumerate(clock) : \n        circuit.append(UnitaryGate(expm(1j * A * t * (2**idx) ), label = f\"$e^{{i A t \\; 2^{idx}}}$\").control(num_ctrl_qubits=1) , [c , b[0] , b[1]])\n    circuit.append(QFT(3, inverse=True), clock)\n    Rotation1 = QuantumCircuit(4, name = \"Ry(θ1)\")\n    theta_1 = 2 * math.asin(1/1.0)\n    Rotation1.append(RYGate(theta_1).control(3, ctrl_state= \"001\"), [1, 2, 3, 0])\n    circuit.append(Rotation1 , range(4))\n    Rotation2 = QuantumCircuit(4, name = \"Ry(θ2)\")\n    theta_2 = 2 * math.asin(1/2.0)\n    Rotation2.append(RYGate(theta_2).control(3, ctrl_state= \"010\"), [1, 2, 3, 0])\n    circuit.append(Rotation2 , range(4))\n    Rotation3 = QuantumCircuit(4, name = \"Ry(θ3)\")\n    theta_3 = 2 * math.asin(1/3.0)\n    Rotation3.append(RYGate(theta_3).control(3, ctrl_state= \"011\"), [1, 2, 3, 0])\n    circuit.append(Rotation3 , range(4))\n    Rotation4 = QuantumCircuit(4, name = \"Ry(θ4)\")\n    theta_4 = 2 * math.asin(1/4.0)\n    Rotation4.append(RYGate(theta_4).control(3, ctrl_state= \"100\"), [1, 2, 3, 0])\n    circuit.append(Rotation4 , range(4))\n    circuit.measure(ancilla, classica_ancialla)\n    circuit.append(QFT(3, inverse=False), clock)\n    for idx, c in enumerate(clock):\n        # If you really want a negative i in the exponent:\n        Uin = expm((-1j * t) * A * 2**(2 - idx))  # Adjust indexing as needed\n        circuit.append(\n            UnitaryGate(Uin, label=f\"$e^{{-i A t \\, 2^{2-idx}}}$\").control(num_ctrl_qubits=1),\n            [clock[2 - idx], b[0], b[1]]\n        )\n    circuit.h(clock)\n    circuit.measure(b , classica_results )\n\n    return circuit", "test": "import unittest\nimport math\ndef normalize_Amplitudes(counts):\n    filtered_counts = {state: count for state, count in counts.items() if state[-1] == '1'}\n    sqrt_total = math.sqrt(sum(filtered_counts.values()))\n    total_sum = sum(filtered_counts.values())\n\n    normalized_amplitudes = {\n        state: math.sqrt(count) / math.sqrt(total_sum) for state, count in filtered_counts.items()\n    }\n    return normalized_amplitudes\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        normalize_amplitudes = normalize_Amplitudes(generated_result)\n        self.assertTrue(normalize_amplitudes.keys() == {\"00 1\",\"01 1\", \"11 1\", \"10 1\"})\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "11", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\n\ndef Deutsch_Jozsa_Balance_4() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit use DeutschJozsa algorithm to solve a oracle with bitstring \"1100\", return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "Deutsch_Jozsa_Balance_4", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\n\ndef Deutsch_Jozsa_Balance_4() -> QuantumCircuit:\n    def dj_oracle(case, n):\n\n        oracle_qc = QuantumCircuit(n+1)\n        if case == \"balanced\":\n            b = np.random.randint(1,2**n)\n            b_str = '1100'\n            for qubit in range(len(b_str)):\n                if b_str[qubit] == '1':\n                    oracle_qc.x(qubit)\n            for qubit in range(n):\n                oracle_qc.cx(qubit, n)\n            for qubit in range(len(b_str)):\n                if b_str[qubit] == '1':\n                    oracle_qc.x(qubit)\n        if case == \"constant\":\n            output = np.random.randint(2)\n            if output == 1:\n                oracle_qc.x(n)\n        \n        oracle_gate = oracle_qc.to_gate() \n        return oracle_gate\n\n    def dj_algorithm(oracle, n):\n        dj_circuit = QuantumCircuit(n+1, n)\n        dj_circuit.x(n)\n        dj_circuit.h(n)\n        for qubit in range(n):\n            dj_circuit.h(qubit)\n        dj_circuit.append(oracle, range(n+1))\n        for qubit in range(n):\n            dj_circuit.h(qubit)\n        for i in range(n):\n            dj_circuit.measure(i, i)\n        return dj_circuit\n    \n    n = 4  \n    oracle_gate = dj_oracle('balanced', n)\n    dj_circuit = dj_algorithm(oracle_gate, n)\n    \n    return dj_circuit", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"1111\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "12", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\n\ndef Deutsch_Jozsa_Constant_4() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit use DeutschJozsa algorithm to solve a oracle with bitstring \"0000\", return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "Deutsch_Jozsa_Constant_4", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\n\ndef Deutsch_Jozsa_Constant_4() -> QuantumCircuit:\n    def dj_oracle(case, n):\n        oracle_qc = QuantumCircuit(n+1)\n        if case == \"balanced\":\n            b = np.random.randint(1,2**n)\n            b_str = '1100'\n            for qubit in range(len(b_str)):\n                if b_str[qubit] == '1':\n                    oracle_qc.x(qubit)\n            for qubit in range(n):\n                oracle_qc.cx(qubit, n)\n            for qubit in range(len(b_str)):\n                if b_str[qubit] == '1':\n                    oracle_qc.x(qubit)\n        if case == \"constant\":\n            output = 0\n            if output == 1:\n                oracle_qc.x(n)\n        oracle_gate = oracle_qc.to_gate() \n        return oracle_gate\n\n    def dj_algorithm(oracle, n):\n        dj_circuit = QuantumCircuit(n+1, n)\n        dj_circuit.x(n)\n        dj_circuit.h(n)\n        for qubit in range(n):\n            dj_circuit.h(qubit)\n        dj_circuit.append(oracle, range(n+1))\n        for qubit in range(n):\n            dj_circuit.h(qubit)\n        for i in range(n):\n            dj_circuit.measure(i, i)\n        return dj_circuit\n\n    n = 4  \n    oracle_gate = dj_oracle('constant', n)\n    dj_circuit = dj_algorithm(oracle_gate, n)\n    \n    return dj_circuit", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"0000\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "13", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Simon_11() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit using Simon's algorithm for the case where:\n            - The input bit length n = 2\n            - The hidden string s = '11'\n        Return a QuantumCircuit after measure the qubit about s.\n    \"\"\"", "entry_point": "Simon_11", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Simon_11() ->QuantumCircuit: \n    qc = QuantumCircuit(4,2)\n    qc.h(0)\n    qc.h(1)\n    for i in range(2):\n        qc.cx(i,2)\n        qc.cx(i,3)\n        qc.h(i)\n    qc.measure(2,0)\n    qc.measure(3,1)\n    \n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"00\", \"11\"})\n        self.assertAlmostEqual(generated_result[\"00\"], generated_result[\"11\"], delta=500)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "14", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Simon_110() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit using Simon's algorithm for the case:\n            - The input bit length n = 3\n            - The hidden string s = '110'\n        Return the QuantumCircuit after measure qubits about s.\n    \"\"\"", "entry_point": "Simon_110", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Simon_110() ->QuantumCircuit: \n    qc = QuantumCircuit(6,3)\n    for i in range(3):\n        qc.h(i)\n    for i in range(3):\n        qc.cx(i,i+3)\n    qc.cx(1,4)\n    qc.cx(1,5)\n    for i in range(3):\n        qc.h(i)\n        qc.measure(i,i)\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"110\", \"111\",\"000\",\"001\"})\n        self.assertAlmostEqual(generated_result[\"110\"], generated_result[\"111\"], delta=300)\n        self.assertAlmostEqual(generated_result[\"000\"], generated_result[\"001\"], delta=300)\n        self.assertAlmostEqual(generated_result[\"110\"], generated_result[\"000\"], delta=300)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "15", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Hadmard_Test_h() ->QuantumCircuit: \n    \"\"\"\n        Implement a 2 qubit Hadmard test quantum circuit for |+> state, return the QuantumCircuit after measure the ancilla qubit.\n    \"\"\"", "entry_point": "Hadmard_Test_h", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Hadmard_Test_h() ->QuantumCircuit: \n    qc = QuantumCircuit(2,1)\n    qc.h(0)\n    qc.h(1)\n    qc.ch(0,1)\n    qc.h(0)\n    qc.measure(0,0)\n    \n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":3,\"ch\":1}.items()), dict(self.generated_circuit.count_ops().items())))\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "16", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Bell_State() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum circuit with Bell State, return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "Bell_State", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Bell_State() ->QuantumCircuit: \n    qc = QuantumCircuit(2,2)\n    qc.h(0)\n    qc.cx(0,1)\n    qc.measure(0,0)\n    qc.measure(1,1)\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":1,\"cx\":1}.items()), dict(self.generated_circuit.count_ops().items())))\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"00\", \"11\"})\n        self.assertAlmostEqual(generated_result[\"00\"], generated_result[\"11\"], delta=500)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "17", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef GHZ() ->QuantumCircuit: \n    \"\"\"\n        Implement a 3 qubits GHZ state quantum circuit, return the QuantumCircuit after measure all qubits. \n    \"\"\"", "entry_point": "GHZ", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef GHZ() ->QuantumCircuit: \n    qc = QuantumCircuit(3,3)\n    qc.h(0)\n    qc.cx(0,1)\n    qc.cx(1,2)\n    qc.measure([0,1,2],[0,1,2])\n    \n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"000\", \"111\"})\n        self.assertAlmostEqual(generated_result[\"000\"], generated_result[\"111\"], delta=500)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "18", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom numpy import pi\ndef Quantum_Teleportation() ->QuantumCircuit: \n    \"\"\"\n        Implement a 3 qubits Quantum_Teleportation, Alice own Qubit 0 and Qubit 1, Bob own Qubit2. Alice's initial state is rotated by angle pi/2 around the X axis. \n        Return QuantumCircuit after just measure Bob's qubit.\n    \"\"\"", "entry_point": "Quantum_Teleportation", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom numpy import pi\ndef Quantum_Teleportation() ->QuantumCircuit: \n    qc = QuantumCircuit(3,1)\n    qc.rx(pi/2,0)\n    qc.h(1)\n    qc.cx(1,2)\n    qc.cx(0,1)\n    qc.h(0)\n    qc.cx(1,2)\n    qc.cz(0,2)\n    qc.measure(2,0)\n\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        qc = self.generated_circuit.copy()\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"0\",\"1\"})\n        self.assertAlmostEqual(generated_result[\"0\"], generated_result[\"1\"], delta=500)\n        self.assertTrue(set({\"h\":2,\"cx\":3}.items())).issubset(set(qc.count_ops().items()))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "19", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef generate_quantum_state_qubit5() ->QuantumCircuit: \n\n        \"\"\"\n                implementation a quantum circuit to create the state ψ = √(1/2)(|00110⟩ + |00101⟩) using qiskit, return the QuantumCircuit after measure all qubits.\n        \"\"\"", "entry_point": "generate_quantum_state_qubit5", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef generate_quantum_state_qubit5() ->QuantumCircuit: \n\n    qc = QuantumCircuit(5,5)\n    qc.x(2)\n    qc.h(3)\n    qc.cx(3,4)\n    qc.x(4)\n    qc.measure([0,1,2,3,4],[4,3,2,1,0])\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"00110\",\"00101\"})\n        self.assertAlmostEqual(generated_result[\"00110\"], generated_result[\"00101\"], delta=500)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "20", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Bernstein_Vazirani_011() ->QuantumCircuit: \n    \"\"\"\n        Implement the Bernstein–Vazirani algorithm for a 3-bit hidden string a = '011'. \n        Return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "Bernstein_Vazirani_011", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Bernstein_Vazirani_011() ->QuantumCircuit: \n    qc = QuantumCircuit(4,3)\n    qc.x(3)\n    qc.h([0,1,2,3])\n    qc.cx(1,3)\n    qc.cx(2,3)\n    qc.h([0,1,2])\n    qc.measure([0,1,2],[0,1,2])\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"110\"})\n        self.assertTrue(is_gate_count_subset(dict({\"h\":7,\"cx\":2,\"x\":1}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "21", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef MAJ_3() ->QuantumCircuit: \n    \"\"\"\n        Implement a 3-input quantum Majority (MAJ) gate using CNOT and CCNOT (Toffoli) gates. \n        The circuit takes as input three qubits:\n            - c_i: the carry bit from the previous stage\n            - b_i: one of the current bits to add\n            - a_i: the other current bit to add\n        The MAJ gate performs the following transformations (reversible logic only):\n            - Output 1: a_i ⊕ b_i \n            - Output 2: a_i ⊕ c_i \n            - Output 3: c_{i+1}, the carry-out of the majority function over a_i, b_i, and c_i\n        Return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "MAJ_3", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef MAJ_3() ->QuantumCircuit: \n    qc = QuantumCircuit(3,3)\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n    qc.ccx(1, 2, 0)\n    qc.measure([0, 1, 2], [0, 1, 2])\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(1)\nqc.h(0)\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n        test_generated = self.generated_circuit.copy()\n        test_generated = test_generated.compose(qc,qubits=[0], front = True)\n        test_generated = test_generated.compose(qc,qubits=[1], front = True)\n        test_generated = test_generated.compose(qc,qubits=[2], front = True)\n        test_oracle = self.oracle_circuit.copy()\n        test_oracle = test_oracle.compose(qc,qubits=[0], front = True)\n        test_oracle = test_oracle.compose(qc,qubits=[1], front = True)\n        test_oracle = test_oracle.compose(qc,qubits=[2], front = True)\n        KL1 = compute_KL(test_oracle, test_generated)\n        self.assertTrue(0<=KL1<0.05)\n    def test_statical_assert(self):\n        qc = self.generated_circuit.copy()\n        self.assertTrue(is_gate_count_subset(dict({\"ccx\":1,\"cx\":2}.items()), dict(qc.count_ops().items())))\n\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "22", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef Qadd() ->QuantumCircuit: \n    \"\"\"\n        Implement a quantum Adder for a = 100, b = 001, and c0 = 1. Return the QuantumCircuit after measure the result qubits.\n    \"\"\"", "entry_point": "Qadd", "canonical_solution": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\ndef Qadd() -> QuantumCircuit:\n    qc = QuantumCircuit(8, 4)\n    qc.x(0)\n    qc.x(1)\n    qc.x(6)\n    def MAJ(qc,ci,bi,ai):\n        qc.cx(ai,bi)\n        qc.cx(ai,ci)\n        qc.ccx(bi,ci,ai)\n        return qc\n    def UMA(qc, ci, bi, ai):\n        qc.ccx(bi,ci,ai)\n        qc.cx(ai,ci)\n        qc.cx(ci,bi)\n        return qc\n    for i in range(3):\n        MAJ(qc,2*i,2*i+1,2*i+2)\n    qc.cx(6,7)\n    for i in range(2,-1,-1):\n        UMA(qc,2*i,2*i+1,2*i+2)\n    qc.measure([1,3,5,7],[0,1,2,3])\n    return qc", "test": "import unittest\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"cx\":13,\"ccx\":6}.items()), dict(self.generated_circuit.count_ops().items())))\n        \n    \n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "23", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\ndef QSub() ->QuantumCircuit: \n    \"\"\"\n        Implement a 3 qubits quantum subtractor for a = 111, b = 011. Return the QuantumCircuit after measure the result qubits.\n    \"\"\"", "entry_point": "QSub", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\ndef QSub(cir = QuantumCircuit(8,3), a = '111', b = '011') ->QuantumCircuit: \n    def to_twos_complement(binary_str):\n        n = len(binary_str)\n        inverted = ''.join('1' if x == '0' else '0' for x in binary_str)\n        inverted_as_int = int(inverted, 2) + 1\n        twos_complement = bin(inverted_as_int)[-n:]\n        if len(twos_complement) < n:\n            twos_complement = '0' * (n - len(twos_complement)) + twos_complement\n        return twos_complement\n\n    def MAJ(qc,ci,bi,ai):\n        qc.cx(ai,bi)\n        qc.cx(ai,ci)\n        qc.ccx(bi,ci,ai)\n        return qc\n    def UMA(qc, ci, bi, ai):\n        qc.ccx(bi,ci,ai)\n        qc.cx(ai,ci)\n        qc.cx(ci,bi)\n        return qc\n    \n    b=to_twos_complement(b)\n    for i,s in enumerate(a[::-1]):\n        if s=='1':\n            cir.x(2*i+2)\n    for i,s in enumerate(b[::-1]):\n        if s=='1':\n            cir.x(2*i+1)\n    l=len(a)\n    cir.barrier()\n    for i in range(l):\n        MAJ(cir,2*i,2*i+1,2*i+2)\n        cir.barrier()\n    cir.cx(len(a)+len(b),len(a)+len(b)+1)\n    for i in range(l-1,-1,-1):\n        cir.barrier()\n        UMA(cir,2*i,2*i+1,2*i+2)\n    cir.measure([1,3,5],[0,1,2])\n    return cir\n\nif __name__ == \"__main__\":\n    a='111'\n    b='011' \n\n    qubit_num=len(a)+len(b)+2\n    #cir = QuantumCircuit(qubit_num)\n    cir = QSub()\n    print(cir)", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"cx\":12,\"x\":5,\"ccx\":6}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "24", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\n\ndef W_State_4() ->QuantumCircuit: \n    \"\"\"\n        Implement a 4 qubits W state quantum circuit. Return the QuantumCircuit after measure all qubits. \n    \"\"\"", "entry_point": "W_State_4", "canonical_solution": "from qiskit import QuantumCircuit\nfrom qiskit.circuit.library import UnitaryGate\nimport numpy as np\n\ndef W_State_4() -> QuantumCircuit:\n    def RBSGate(theta):\n        rbs_matrix = np.array([\n            [1, 0,          0,         0],\n            [0, np.cos(theta), -np.sin(theta), 0],\n            [0, np.sin(theta),  np.cos(theta), 0],\n            [0, 0,          0,         1]\n        ])\n        return UnitaryGate(rbs_matrix, label=\"RBS\")\n    \n    qc = QuantumCircuit(4,4)    \n    qc.x(0)\n    qc.append(RBSGate(np.arccos(1/np.sqrt(4))), [0, 1])\n    qc.append(RBSGate(np.arccos(1/np.sqrt(3))), [1, 2])\n    qc.append(RBSGate(np.arccos(1/np.sqrt(2))), [2, 3])\n    qc.measure([0, 1, 2, 3], [0, 1, 2, 3])\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"0001\",\"0100\", \"1000\", \"0010\"})\n        self.assertAlmostEqual(generated_result[\"0001\"], generated_result[\"1000\"], delta=300)\n        self.assertAlmostEqual(generated_result[\"0100\"], generated_result[\"0010\"], delta=300)\n        self.assertAlmostEqual(generated_result[\"0001\"], generated_result[\"0100\"], delta=300)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "25", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef qpe_grover00_gate(n_count=3) ->QuantumCircuit: \n    \n    \"\"\"\n        Use Grover’s algorithm to mark state |00⟩, then apply a 3 qubits Quantum Phase Estimation using the Grover operator as the unitary.\n        Return the QuantumCircuit after measure all qubits.\n    \"\"\"", "entry_point": "qpe_grover00_gate", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\nfrom qiskit.circuit.library import QFT\n\ndef qpe_grover00_gate(n_count=3):\n    def grover_search_oracle_00() ->QuantumCircuit:\n        qc = QuantumCircuit(2)\n        qc.h(0)\n        qc.h(1)\n        qc.x(0)\n        qc.x(1)\n        qc.h(1)\n        qc.cx(0,1)\n        qc.x(0)\n        qc.h(1)\n        qc.h(0)\n        qc.x(1)\n        qc.h(1)\n        return qc\n\n    grover_00 = grover_search_oracle_00().to_gate()\n    cgrover_00 = grover_00.control(1)\n    qc = QuantumCircuit(n_count + 2, n_count)\n    qc.h(range(n_count))\n    qc.x(range(n_count,n_count+2))\n\n    for qubit in range(n_count):\n        repetitions = 2**qubit\n        for _ in range(repetitions):\n            qc.append(cgrover_00,[qubit, n_count,n_count+1])\n\n    qc.append(QFT(n_count, inverse=True, do_swaps=True).to_gate(), range(n_count))\n\n    qc.measure(range(n_count), range(n_count))\n\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "26", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef GHZ3_SWAPTEST() ->QuantumCircuit: \n    \n    \"\"\"\n        Prepare a 3-qubit GHZ state and compare it with a |+++> state using the SWAP test. Use 3 ancilla qubits and measure ancilla qubits.\n    \"\"\"", "entry_point": "GHZ3_SWAPTEST", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef GHZ3_SWAPTEST() ->QuantumCircuit: \n    qc = QuantumCircuit(9,3)\n    qc.h([0,1,2])\n    qc.h(3)\n    qc.cx(3,4)\n    qc.cx(4,5)\n    qc.h([6,7,8])\n    for i in range(3):\n        qc.cswap(i,i+2,i+5)\n    qc.h([0,1,2])\n    qc.measure([0,1,2],[0,1,2])\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":6,\"cswap\":3,\"cx\":2}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "27", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef decompose_CNOT() ->QuantumCircuit: \n    \n    \"\"\"\n        Decompose CNOT gate use Hadmard gate and CZ gate. Return the QuantumCircuit without measure.\n    \"\"\"", "entry_point": "decompose_CNOT", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef decompose_CNOT() ->QuantumCircuit: \n    qc = QuantumCircuit(2,2)\n    qc.h(1)\n    qc.cz(0,1)\n    qc.h(1)\n    qc.measure(0,0)\n    qc.measure(1,1)\n    return qc", "test": "import unittest\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        pass\n\n    def test_statical_assert(self):\n        self.assertTrue(unitary_equivalent(self.oracle_circuit, self.generated_circuit))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "28", "complete_prompt": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef decompose_CCCNOT() ->QuantumCircuit: \n    \n    \"\"\"\n        Implement a 5 qubits quantum circuit, construct a decomposition of the CCCNOT (triple-controlled NOT) gate using CCNOT gate. qubit0, qubit1, and qubit2 act as control qubits, qubit 3 is ancilla qubit, and qubit4 is the target qubit.\n        Return the QuantumCircuit after measure control and target qubits.\n    \"\"\"", "entry_point": "decompose_CCCNOT", "canonical_solution": "from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\ndef decompose_CCCNOT() ->QuantumCircuit: \n    qc = QuantumCircuit(5, 4)\n    qc.ccx(0, 1, 3)\n    qc.ccx(2, 3, 4)\n    qc.ccx(0, 1, 3)\n\n    qc.measure([0,1,2,3], [0,1,2,3])\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc= QuantumCircuit(3)\nqc.h([0,1,2])\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n        test_generated_circuit = self.generated_circuit.copy()\n        test_generated_circuit = test_generated_circuit.compose(qc, qubits=[0,1,2], front=True)\n        test_oracle_circuit = self.oracle_circuit.copy()\n        test_oracle_circuit = test_oracle_circuit.compose(qc, qubits=[0,1,2], front=True)\n        KL1 = compute_KL(test_oracle_circuit, test_generated_circuit)\n        self.assertTrue(0<=KL1<0.05)\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "29", "complete_prompt": "from qiskit import QuantumCircuit\nfrom numpy import pi\n\ndef chsh_circuit(alice: int, bob: int)->QuantumCircuit:\n    \"\"\" \n        Design a CHSH circuit that takes bits of Alice and Bob as input and return the Quantum Circuit after measuring.\n    \"\"\"", "entry_point": "chsh_circuit", "canonical_solution": "from qiskit import QuantumCircuit\nfrom numpy import pi\ndef chsh_circuit(alice: int, bob: int)->QuantumCircuit:\n    qc = QuantumCircuit(2,  2)\n    qc.h(0)   \n    qc.cx(0, 1)\n    qc.barrier()\n    if alice == 0:        \n        qc.ry(0, 0)\n    else:\n        qc.ry(-pi / 2, 0)    \n        qc.measure(0, 0)\n        if bob == 0:       \n            qc.ry(-pi / 4, 1)\n        else:\n            qc.ry(pi / 4, 1)\n            qc.measure(1, 1)\n    return qc", "test": "import unittest\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution(1,1)\n        self.generated_circuit = cir_generated(1,1)\n        self.oracle_circuit1 = cir_solution(1,0)\n        self.generated_circuit1 = cir_generated(1,0)\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n        KL1 = compute_KL(self.oracle_circuit1, self.generated_circuit1)\n        self.assertTrue(0<=KL1<0.05)\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":1,\"cx\":1,\"ry\":2}.items()), dict(self.generated_circuit.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "30", "complete_prompt": "from qiskit import QuantumCircuit\n\ndef or_circuit()->QuantumCircuit:\n    \"\"\" \n        Design a or circuit that takes Qubit 0 and Qubit 1 as input and Qubit 3 as result, return the Quantum Circuit after measure Qubit 2.\n    \"\"\"", "entry_point": "or_circuit", "canonical_solution": "from qiskit import QuantumCircuit\n\ndef or_circuit()->QuantumCircuit:\n    qc = QuantumCircuit(3,1)\n    qc.x(0)\n    qc.x(1)\n    qc.ccx(0, 1, 2)\n    qc.x(2)    \n    qc.measure(2, 0)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.x([0,1])\nqc1 = QuantumCircuit(2)\nqc1.x(0)\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n        test_generated_circuit = self.generated_circuit.copy()\n        test_generated_circuit = test_generated_circuit.compose(qc, qubits=[0,1], front = True)\n        test_oracle_circuit = self.oracle_circuit.copy()\n        test_oracle_circuit = test_oracle_circuit.compose(qc, qubits=[0,1], front = True)\n        KL1 = compute_KL(test_oracle_circuit, test_generated_circuit)\n        self.assertTrue(0<=KL1<0.05)\n\n        test_generated_circuit1 = self.generated_circuit.copy()\n        test_generated_circuit1 = test_generated_circuit1.compose(qc1, qubits=[0,1], front = True)\n        test_oracle_circuit1 = self.oracle_circuit.copy()\n        test_oracle_circuit1 = test_oracle_circuit1.compose(qc1, qubits=[0,1], front = True)\n        KL2 = compute_KL(test_oracle_circuit1, test_generated_circuit1)\n        self.assertTrue(0<=KL2<0.05)\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "31", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef period_finding_7_15()->QuantumCircuit:\n    \"\"\"\n        Design a quantum circuit to solve the Period Finding Problem (with a = 7,  N = 15), return the Quantum Circuit after measuring.\n    \"\"\"", "entry_point": "period_finding_7_15", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\ndef period_finding_7_15()->QuantumCircuit:\n    N = 15\n    m = int( np.ceil( np.log2( N ) ) )\n    U_qc = QuantumCircuit(m,m)\n    U_qc.x( range(m) )\n    U_qc.swap(1, 2)\n    U_qc.swap(2, 3)\n    U_qc.swap(0, 3)\n    U_qc.measure(range(m),range(m))\n    return U_qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "32", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef shor_7mod15()->QuantumCircuit:\n    \"\"\"\n        Design a quantum circuit that implentment a shor's algorithm to solve 7 mod 15, Use a 8 qubits for the phase register and 4 qubits for the modular exponentiation.\n        Return the Quantum Circuit after measuring phase register.\n    \"\"\"", "entry_point": "shor_7mod15", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\nfrom qiskit.circuit.library import QFT\ndef shor_7mod15()->QuantumCircuit:\n    N = 15\n    m = int( np.ceil( np.log2( N ) ) )\n    phase_register_size = 8\n    cu_register_size = 4\n    qc = QuantumCircuit(phase_register_size + cu_register_size, phase_register_size)\n    qc.h(range(8))\n    qc.x(8)\n\n    def cU_multi(k):\n        U_qc = QuantumCircuit( m )\n        U_qc.x( range(m) )\n        U_qc.swap(1, 2)\n        U_qc.swap(2, 3)\n        U_qc.swap(0, 3)\n        U = U_qc.to_gate()\n        sys_register_size = 4\n        circ = QuantumCircuit( sys_register_size )\n        for _ in range(2**k):\n            circ.append(U, range(sys_register_size))\n        U_multi = circ.to_gate()\n        U_multi.name = \"7Mod15_[2^{}]\".format(k)\n        cU_multi = U_multi.control()\n        return cU_multi\n    \n    # def apply_qft_inverse(n):\n    #     qc = \n    for k in range( phase_register_size ):\n        cU = cU_multi(k)\n        qc.append( cU, [k] + list( range( phase_register_size,\n                                                ( phase_register_size + cu_register_size ) ) ) )\n\n    # for qubit_idx in range( phase_register_size // 2 ):\n    #     qc.swap( qubit_idx, ( 8 - qubit_idx - 1 ) )\n    qc.append(QFT(phase_register_size).inverse(), range(phase_register_size))\n    qc.measure(range( phase_register_size ),range( phase_register_size ))\n\n    return qc", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"11000000\",\"01000000\",\"00000000\",\"10000000\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "33", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\ndef ipe_s_gate() -> QuantumCircuit:\n    \"\"\"\n        Implement an Iterative Phase Estimation (IPE) circuit to estimate the phase of the S gate, using 2 iterations.\n        Return the QuantumCircuit with measurements.\n    \"\"\"", "entry_point": "ipe_s_gate", "canonical_solution": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom qiskit_aer import AerSimulator\nimport numpy as np\ndef ipe_s_gate() -> QuantumCircuit:\n    qr = QuantumRegister(2, 'q')\n    cr = ClassicalRegister(2, 'c')\n    qc = QuantumCircuit(qr, cr)\n    qc.h(0)\n    qc.x(1)\n    qc.cp(np.pi, 0, 1)\n    qc.h(0)\n    qc.measure(0, 0)\n    qc.reset(0)\n    qc.h(0)\n    with qc.if_test((cr[0], True)):\n        qc.p( -np.pi / 2, 0 )\n    qc.cp(np.pi/2, 0 ,1)\n    qc.h(0)\n    qc.measure(0, 1)\n    return qc\n\nif __name__ == \"__main__\":\n    # 创建一个模拟器\n    simulator = AerSimulator()\n\n    # 执行电路并获取结果\n    circuit = ipe_s_gate()\n    print(circuit)\n    result = simulator.run(circuit).result()\n    counts = result.get_counts(circuit)\n\n    # 打印结果\n    print(\"Counts:\", counts)", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"01\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "34", "complete_prompt": "from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nimport numpy as np\ndef ipe_t_gate() -> QuantumCircuit:\n    \"\"\"\n        Implement an Iterative Phase Estimation (IPE) circuit to estimate the phase of the T gate, using 3 iterations.\n        Return the QuantumCircuit with measurements.\n    \"\"\"", "entry_point": "ipe_t_gate", "canonical_solution": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nimport numpy as np\nfrom qiskit_aer import AerSimulator\ndef ipe_t_gate() -> QuantumCircuit:\n    qr = QuantumRegister(2)\n    cr = ClassicalRegister(3)\n    qc = QuantumCircuit(qr, cr)\n    qc.h(0)\n    qc.x(1)\n    qc.cp(np.pi,0,1)\n    qc.h(0)\n    qc.measure(0,0)\n    qc.reset(0)\n    qc.h(0)\n    with qc.if_test( ( cr[0], True ) ): \n        qc.p( -np.pi / 2, 0 )\n    qc.cp(np.pi/2,0,1)\n    qc.h(0)\n    qc.measure(0,1)\n    qc.reset(0)\n    qc.h(0)\n    with qc.if_test( ( cr[0], True ) ): \n        qc.p( -np.pi / 4, 0 )\n    qc.cp(np.pi/4,0,1)\n    qc.h(0)\n    qc.measure(0,2)\n    return qc\n\n# if __name__ == \"__main__\":\n#     # 创建一个模拟器\n#     simulator = AerSimulator()\n\n#     # 执行电路并获取结果\n#     circuit = ipe_t_gate()\n#     result = simulator.run(circuit).result()\n#     counts = result.get_counts(circuit)\n\n#     # 打印结果\n#     print(\"Counts:\", counts)", "test": "import unittest\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"001\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "35", "complete_prompt": "from qiskit import QuantumCircuit\ndef parity_check_3bit() -> QuantumCircuit:\n    \"\"\"\n        Construct a quantum circuit to check the parity of a 3-qubit input state and return quantum circuit after measure one qubit\n    \"\"\"", "entry_point": "parity_check_3bit", "canonical_solution": "from qiskit import QuantumCircuit\ndef parity_check_3bit() -> QuantumCircuit:\n    qc = QuantumCircuit(4, 1)\n    qc.cx(0, 3)\n    qc.cx(1, 3)\n    qc.cx(2, 3)\n    qc.measure(3, 0)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(3)\nqc.x([0,2])\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        generated_result = run_circuit(self.generated_circuit)\n        self.assertTrue(generated_result.keys() == {\"0\"})\n        test_generated_circuit = self.generated_circuit.copy()\n        test_generated_circuit = test_generated_circuit.compose(qc,qubits= [0,1,2], front = True)\n        test_result = run_circuit(test_generated_circuit)\n        self.assertTrue(test_result.keys() == {\"1\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "36", "complete_prompt": "from qiskit import QuantumCircuit\ndef reverse_state_preparation_bell() -> QuantumCircuit:\n    \"\"\"\n        Build a circuit to uncompute the Bell state back to |00>. Return the QuantumCircuit after measurement.\n    \"\"\"", "entry_point": "reverse_state_preparation_bell", "canonical_solution": "from qiskit import QuantumCircuit\ndef reverse_state_preparation_bell() -> QuantumCircuit:\n    qc = QuantumCircuit(2, 2)\n    qc.cx(0, 1)\n    qc.h(0)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0,1)\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"h\":1,\"cx\":1}.items()), dict(self.generated_circuit.count_ops().items())))\n        test_generated_circuit = self.generated_circuit.copy()\n        test_generated_circuit = test_generated_circuit.compose(qc,qubits= [0,1], front = True)\n        test_result = run_circuit(test_generated_circuit)\n        self.assertTrue(test_result.keys() == {\"00\"})\n        \n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "37", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef controlled_hadamard() -> QuantumCircuit:\n    \"\"\"\n        Decompose a controlled-Hadamard gate using basic gates. Return the QuantumCircuit after measure.\n    \"\"\"", "entry_point": "controlled_hadamard", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\ndef controlled_hadamard() -> QuantumCircuit:\n    qc = QuantumCircuit(2, 2)\n    qc.ry(np.pi/4, 1)\n    qc.cx(0, 1)\n    qc.ry(-np.pi/4, 1)\n    qc.measure(0, 0)\n    qc.measure(1, 1)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.h(0)\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        qc1 = qc.compose(self.generated_circuit,qubits=[0,1])\n        result = run_circuit(qc1)\n        self.assertTrue(result.keys() == {\"00\",\"01\",\"11\"})\n        self.assertAlmostEqual(result[\"00\"], (result[\"01\"]+result[\"11\"]), delta=500)\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "38", "complete_prompt": "import pennylane as qml\ndef QCL_circuit(weights, n_qubits, depth):\n    \"\"\"\n        Create a Parameterized Quantum Circuit（PQC）based model to solve the image classification task of MNIST dataset.\n    \"\"\"", "entry_point": "QCL_circuit", "canonical_solution": "import pennylane as qml\ndef QCL_circuit(weights, n_qubits, depth):\n    for d in range(depth):\n        for i in range(n_qubits - 1):\n            qml.CNOT(wires=[i, i + 1])\n        qml.CNOT(wires=[n_qubits - 1, 0])\n        for i in range(n_qubits):\n            qml.RX(weights[d, i, 0], wires=i)\n            qml.RZ(weights[d, i, 1], wires=i)\n            qml.RX(weights[d, i, 2], wires=i)", "test": "import unittest\nimport os\nimport pennylane as qml\nimport torch\nimport torch.nn as nn\nfrom pennylane import AmplitudeEmbedding\nimport torchvision.datasets as datasets\nimport torchvision.transforms as transforms\nfrom torch.utils.data import DataLoader, TensorDataset, random_split, Subset\nimport numpy as np\nimport time\nfrom sklearn.metrics import accuracy_score\nfrom tqdm import tqdm\ndepth = 5\nn_qubits = 10\ndev = qml.device(\"default.qubit\", wires=n_qubits)\ndir = './'\n\ndef check(QCL_circuit):\n    def qcl_circuit(weights, n_qubits, depth):\n        QCL_circuit(weights, n_qubits, depth)\n\n\n    class QCL(nn.Module):\n        def __init__(self, num_classes=2):\n            super(QCL, self).__init__()\n            self.dev = dev\n            self.num_classes = num_classes\n            weight_shapes = {'weights': (depth, n_qubits, 3)}\n            self.ql = qml.qnn.TorchLayer(self.create_circuit(dev), weight_shapes)\n\n        @staticmethod\n        def create_circuit(dev):\n            @qml.qnode(dev, interface='torch')\n            def circuit(inputs, weights):\n                inputs = inputs.to(torch.float64)\n                AmplitudeEmbedding(inputs, wires=range(n_qubits), normalize=True, pad_with=0)\n                # qcl_circuit(weights, n_qubits, depth)\n                QCL_circuit(weights, n_qubits, depth)\n                #return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]\n                \n            return circuit\n\n        def forward(self, x, y):\n            preds = self.predict(x)\n            criterion = nn.CrossEntropyLoss()\n            loss = criterion(preds, y)\n            return loss\n\n        def predict(self, x):\n            x = torch.flatten(x, start_dim=1)\n            x = self.ql(x)\n            return x[:, :self.num_classes]\n\n    # parameters for model training\n    data_scale = 0.2\n    class_idx = [0, 1]\n    num_classes = len(class_idx)\n    epochs = 1\n    batch_size = 64\n    lr = 0.01\n    milestones = [5, 10, 15, 20]\n\n    # load train and test data\n    def load_data():\n        path = os.path.join(dir, 'dataset')\n        if not os.path.exists(path):\n            os.mkdir(path)\n        train_set = datasets.MNIST(dir, train=True, download=True, transform=transforms.ToTensor())\n        test_set = datasets.MNIST(dir, train=False, download=True, transform=transforms.ToTensor())\n\n        def filter_and_subset(dataset):\n            targets = dataset.targets\n            mask = torch.zeros_like(targets, dtype=torch.bool)\n            for c in class_idx:\n                mask |= (targets == c)\n            class_indices = torch.where(mask)[0]\n\n            subset_size = int(len(class_indices) * data_scale)\n            selected_indices = np.random.choice(class_indices.numpy(), subset_size, replace=False)\n            return Subset(dataset, selected_indices)\n\n        train_subset = filter_and_subset(train_set)\n        test_subset = filter_and_subset(test_set)\n\n        return DataLoader(train_subset, batch_size=batch_size, shuffle=True), DataLoader(test_subset, batch_size=batch_size, shuffle=False)\n\n    # training\n    def train(model, train_data, test_data):\n        optimizer = torch.optim.Adam(model.parameters(), lr=lr)\n        scheduler = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=milestones)\n        best_acc = 0\n\n        epoch_l = []\n        train_loss = []\n        test_loss = []\n        train_acc = []\n        test_acc = []\n        for epoch in range(epochs):\n            print(f'===== Epoch {epoch + 1} =====')\n            epoch_l.append(epoch + 1)\n            s_time = time.perf_counter()\n            model.train()\n\n            y_trues = []\n            y_preds = []\n            total_loss = 0\n            for (images, labels) in tqdm(train_data):\n                optimizer.zero_grad()\n\n                loss = model(images, labels)\n                total_loss += loss.item()\n                outputs = model.predict(images)\n\n                loss.backward()\n                optimizer.step()\n\n                y_trues += labels.cpu().numpy().tolist()\n                y_preds += outputs.data.cpu().numpy().argmax(axis=1).tolist()\n\n            e_time = time.perf_counter()\n            train_acc_ = accuracy_score(y_trues, y_preds)\n            train_loss.append(total_loss / len(train_data))\n            train_acc.append(train_acc_ * 100)\n\n            scheduler.step()\n\n            model.eval()\n            y_trues = []\n            y_preds = []\n            total_loss = 0\n            for i, (images, labels) in enumerate(test_data):\n                with torch.no_grad():\n                    outputs = model.predict(images)\n                    loss = model(images, labels)\n                    total_loss += loss.item()\n                y_trues += labels.cpu().numpy().tolist()\n                y_preds += outputs.data.cpu().numpy().argmax(axis=1).tolist()\n\n            test_acc_ = accuracy_score(y_trues, y_preds)\n            test_loss.append(total_loss / len(test_data))\n            test_acc.append(test_acc_ * 100)\n\n            return test_acc\n    model = QCL(num_classes=num_classes)\n    train_data, test_data = load_data()\n    test_acc = train(model, train_data, test_data)\n    return test_acc\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.generated_circuit = cir_generated\n\n    def test_functional_equality(self):\n        test_acc = check(self.generated_circuit)\n        self.assertTrue(90<test_acc<100)\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "39", "complete_prompt": "from qiskit import QuantumCircuit\nfrom qiskit.circuit import ParameterVector\ndef quantum_state_preparation(parameters: ParameterVector) -> QuantumCircuit:\n    \"\"\"\n        Prepares a single-qubit variational quantum state based on input parameters. This function constructs a parameterized ansatz circuit consisting of RX and RY rotationson a single qubit.\n        Return the QuantumCircuit without measure.\n    \"\"\"", "entry_point": "quantum_state_preparation", "canonical_solution": "from qiskit import QuantumCircuit\nfrom qiskit.circuit import ParameterVector\nfrom qiskit.quantum_info import SparsePauliOp\ndef quantum_state_preparation(parameters) -> QuantumCircuit:\n    circuit = QuantumCircuit(1)\n    circuit.rx(parameters[0], 0) \n    circuit.ry(parameters[1], 0)\n    return circuit", "test": "import unittest\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister\nfrom qiskit.primitives import Estimator\nfrom numpy.linalg import eigvalsh\nfrom qiskit.circuit import ParameterVector\nfrom qiskit.quantum_info import SparsePauliOp\n\ndef check(quantum_state_preparation):\n    def hamiltonian_operator(a, b, c, d):\n        pauli_labels = ['I', 'Z', 'X', 'Y']\n        coeffs = [a, b, c, d]\n        return SparsePauliOp(pauli_labels, coeffs=coeffs)\n    \n    scale = 10\n    a = 2.68391\n    b = 9.12378\n    c = 1.04722\n    d = 5.89003\n    H = hamiltonian_operator(a, b, c, d)\n\n    exact_result = min(eigvalsh(H.to_matrix()))\n    \n    def vqe_circuit():\n        q = QuantumRegister(1)\n        c = ClassicalRegister(1)\n        circuit = QuantumCircuit(q, c)\n        parameters = ParameterVector('θ', 2)\n        raw_ansatz = circuit.compose(quantum_state_preparation(parameters))\n        return  raw_ansatz\n\n    def cost_func_vqe(params, ansatz, hamiltonian, estimator):\n\n        job = estimator.run(\n            circuits=[ansatz],\n            observables=[hamiltonian],\n            parameter_values=[params]\n        )\n        result = job.result()\n        energy = result.values[0] \n\n        return energy\n\n    circuit = vqe_circuit()\n    x0 = np.ones(circuit.num_parameters)\n    estimator = Estimator()\n    result = minimize(cost_func_vqe, x0, args=(circuit, H, estimator), method=\"COBYLA\", options={'maxiter': 10000, 'disp': True})\n    if abs(result.fun-exact_result) < 1e-2:\n        return True\n    else:\n        return False\n    \n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        \n        self.generated_circuit = cir_generated\n\n    def test_functional_equality(self):\n        self.assertTrue(check(self.generated_circuit))\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "40", "complete_prompt": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.circuit.library import U3Gate\nfrom qiskit.circuit import ParameterVector\nimport numpy as np\ndef VQE_2(parameters) -> QuantumCircuit:\n    \"\"\"\n    Prepares a double-qubit variational quantum state based on input parameters. This function constructs a parameterized ansatz circuit to find the eigenvalue of the observable.\n    Args:\n        parameters (list or array-like): A list of 8 real-valued parameters:\n            - parameters[0–2]: RZ, RZ, RY rotations on qubit 0\n            - parameters[3]:    RZ rotation on qubit 1\n            - parameters[4–6]: RZ, RZ, RY on qubit 0\n            - parameters[7]:    RZ rotation on qubit 1\n    Return the QuantumCircuit without measure.\n    \"\"\"", "entry_point": "VQE_2", "canonical_solution": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.circuit.library import U3Gate\nfrom qiskit.circuit import ParameterVector\nimport numpy as np\ndef VQE_2(parameters: ParameterVector) -> QuantumCircuit:\n    qr = QuantumRegister(2)\n    circuit = QuantumCircuit(qr)\n    circuit.append(U3Gate(np.pi,0,np.pi) ,[qr[0]])\n    circuit.rz(parameters[0], 0)\n    circuit.rz(parameters[1], 0)\n    circuit.ry(parameters[2], 0)\n    circuit.rz(parameters[3], 1)\n    circuit.cx(0, 1)\n    circuit.rz(parameters[4], 0)\n    circuit.rz(parameters[5], 1)\n    circuit.ry(parameters[6], 0)\n    circuit.rz(parameters[7], 1)\n    return circuit", "test": "import unittest\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nfrom qiskit.circuit.library import U3Gate\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom numpy.linalg import eigvalsh\nfrom qiskit.primitives import  Estimator\nfrom qiskit.circuit import ParameterVector\n\ndef check(VQE_2):\n    observable_1 = SparsePauliOp.from_list([(\"II\", 2), (\"XX\", -2), (\"YY\", 3), (\"ZZ\", -3)])\n    exact_result = min(eigvalsh(observable_1.to_matrix()))\n\n    def cost_func_vqe(params, ansatz, hamiltonian, estimator):\n\n        job = estimator.run(\n            circuits=[ansatz],\n            observables=[hamiltonian],\n            parameter_values=[params]\n        )\n        result = job.result()\n        energy = result.values[0] \n\n        return energy\n\n    reference_circuit = QuantumCircuit(2)\n    reference_circuit.x(0)\n    variational_form = VQE_2(ParameterVector('θ', 8))\n    raw_ansatz = reference_circuit.compose(variational_form)\n    x0 = np.ones(raw_ansatz.num_parameters)\n    estimator = Estimator()\n    result = minimize(cost_func_vqe, x0, args=(raw_ansatz, observable_1, estimator), method=\"COBYLA\", options={'maxiter': 10000, 'disp': True})\n    if abs(result.fun-exact_result) < 1e-2:\n        return True\n    else:\n        return False\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        \n        self.generated_circuit = cir_generated\n\n    def test_functional_equality(self):\n        self.assertTrue(check(self.generated_circuit))\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "41", "complete_prompt": "import numpy as np\nfrom qiskit.circuit import ParameterVector, QuantumCircuit\nfrom qiskit.primitives import Estimator, Sampler\nfrom qiskit.quantum_info import SparsePauliOp\nfrom scipy.optimize import minimize\n\ndef VQE_Z2():\n    \"\"\"\n    Implement a quantum circuit compute the minimum eigenvalue of the Z2 Hamiltonian using the Variational Quantum Eigensolver (VQE) algorithm. \n    Return the QuantumCircuit without measure.\n    \"\"\"", "entry_point": "VQE_Z2", "canonical_solution": "from qiskit import QuantumCircuit\n\ndef VQE_Z2(param):\n    qc = QuantumCircuit(2, 2)\n    qc.u(param[0], param[1], param[2], 0)\n    qc.u(param[3], param[4], param[5], 1)\n    return qc", "test": "import unittest\nimport numpy as np\nfrom qiskit.quantum_info import SparsePauliOp\nfrom qiskit import QuantumCircuit\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom numpy.linalg import eigvalsh\nfrom qiskit.primitives import  Estimator\nfrom qiskit.circuit import ParameterVector\ndef check(VQE_Z2):\n    z2 = SparsePauliOp(\"ZZ\")\n    exact_result = min(eigvalsh(z2.to_matrix()))\n\n    def cost_func_vqe(params, ansatz, hamiltonian, estimator):\n\n            job = estimator.run(\n                circuits=[ansatz],\n                observables=[hamiltonian],\n                parameter_values=[params]\n            )\n            result = job.result()\n            energy = result.values[0] \n\n            return energy\n\n    param = ParameterVector(\"a\", 6)\n    def VQE_Z2(param):\n        z2 = SparsePauliOp(\"ZZ\")\n        qc = QuantumCircuit(2, 2)\n        qc.u(param[0], param[1], param[2], 0)\n        qc.u(param[3], param[4], param[5], 1)\n        return qc\n\n    reference_circuit = QuantumCircuit(2)\n    reference_circuit.x(0)\n    variational_form = VQE_Z2(ParameterVector('θ', 8))\n    raw_ansatz = reference_circuit.compose(variational_form)\n    x0 = np.ones(raw_ansatz.num_parameters)\n    estimator = Estimator()\n    result = minimize(cost_func_vqe, x0, args=(raw_ansatz, z2, estimator), method=\"COBYLA\", options={'maxiter': 10000, 'disp': True})\n    if abs(result.fun-exact_result) < 1e-2:\n        return True\n    else:\n        return False\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        \n        self.generated_circuit = cir_generated\n\n    def test_functional_equality(self):\n        self.assertTrue(check(self.generated_circuit))\n\n    def test_statical_assert(self):\n        pass\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "42", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef U_gate_decompose(theta, phi, lam) -> QuantumCircuit:\n    \"\"\"\n    Decompose U gate into a sequence of RZ and SX gates, ignore the goble phase, return the quantum circuit without measure.\n    \"\"\"", "entry_point": "U_gate_decompose", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\ndef U_gate_decompose(theta, phi, lam) -> QuantumCircuit: \n    qc = QuantumCircuit(1)\n    qc.rz(lam, 0)\n    qc.sx(0)\n    qc.rz(theta + np.pi, 0)\n    qc.sx(0)\n    qc.rz(phi + 3*np.pi, 0)\n    return qc", "test": "import unittest\nimport numpy as np\ndef random_angle():\n    return np.random.uniform(0, 2 * np.pi, size=5)[0]\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution\n        self.generated_circuit = cir_generated\n        \n    def test_functional_equality(self):\n        for i in range(3):\n            theta = random_angle()\n            phi = random_angle()\n            lam = random_angle()\n            qc1 = self.oracle_circuit(theta, phi, lam)\n            qc2 = self.generated_circuit(theta, phi, lam)\n            qc1.measure_all()\n            qc2.measure_all()\n            KL = compute_KL(qc1, qc2)\n            self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        theta = random_angle()\n        phi = random_angle()\n        lam = random_angle()\n        qc2 = self.generated_circuit(theta, phi, lam)  \n        self.assertTrue(is_gate_count_subset(dict({\"rz\":1,\"sx\":1}.items()), dict(qc2.count_ops().items())))\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "43", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef Toffoli_gate_decompose() -> QuantumCircuit:\n    \"\"\"\n    Decompose Toffoli gate into a sequence of RZ, SX and CX gates, ignore the goble phase, return the quantum circuit without measure.\n    \"\"\"", "entry_point": "Toffoli_gate_decompose", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\ndef Toffoli_gate_decompose() -> QuantumCircuit:\n    qc = QuantumCircuit(3)\n    qc.rz(np.pi/2,2)\n    qc.sx(2)\n    qc.rz(np.pi/2,2)\n    qc.cx(1,2)\n    qc.rz(-np.pi/4,2)\n    qc.cx(0,2)\n    qc.rz(np.pi/4,2)\n    qc.cx(1,2)\n    qc.rz(np.pi/4,1)\n    qc.cx(0,2)\n    qc.cx(0,1)\n    qc.rz(3*np.pi/4,2)\n    qc.rz(np.pi/4,0)\n    qc.rz(-np.pi/4,1)\n    qc.sx(2)\n    qc.cx(0,1)\n    qc.rz(np.pi/2,2)\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(3,3)\nqc.h([0,1])\nqc1 = QuantumCircuit(3,3)\nqc1.h([0,1])\nqc2 = QuantumCircuit(3,1)\nqc2.x([0,1])\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n        \n\n    def test_functional_equality(self):\n        qc_copy = qc.compose(self.oracle_circuit,qubits=[0,1,2])\n        qc_copy.measure([0,1,2],[0,1,2])\n        qc1_copy = qc1.compose(self.generated_circuit,qubits=[0,1,2])\n        qc1_copy.measure([0,1,2],[0,1,2])\n        KL = compute_KL(qc_copy, qc1_copy)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        self.assertTrue(is_gate_count_subset(dict({\"rz\":1,\"sx\":1,\"cx\":1}.items()), dict(self.generated_circuit.count_ops().items())))\n        qc2_copy = qc2.compose(self.generated_circuit,qubits=[0,1,2])\n        qc2_copy.measure(2,0)\n        result =run_circuit(qc2_copy)\n        self.assertTrue(result.keys()=={\"1\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
{"task_id": "44", "complete_prompt": "from qiskit import QuantumCircuit\nimport numpy as np\ndef CX_gate_decompose_Clifford() -> QuantumCircuit:\n    \"\"\"\n    Decompose CX gate into a sequence of local Clifford gates, return the quantum circuit after measure all qubits.\n    \"\"\"", "entry_point": "CX_gate_decompose_Clifford", "canonical_solution": "from qiskit import QuantumCircuit\nimport numpy as np\ndef CX_gate_decompose_Clifford() -> QuantumCircuit:\n    qc = QuantumCircuit(2,2)\n    qc.sdg(0)\n    qc.s(1)\n    qc.h(1)\n    qc.s(1)\n    qc.ecr(0, 1)\n    qc.x(0)\n    qc.measure([0,1],[0,1])\n    return qc", "test": "import unittest\nfrom qiskit import QuantumCircuit\nqc = QuantumCircuit(2)\nqc.h(0)\n\nclass TestKLDivergence(unittest.TestCase):\n    def setUp(self):\n        self.oracle_circuit = cir_solution()\n        self.generated_circuit = cir_generated()\n\n    def test_functional_equality(self):\n        KL = compute_KL(self.oracle_circuit, self.generated_circuit)\n        self.assertTrue(0<=KL<0.05)\n\n    def test_statical_assert(self):\n        qc_copy = self.generated_circuit.copy()\n        self.assertTrue(is_gate_count_subset(dict({\"x\":1,\"s\":1,\"h\":1,\"sdg\":1,\"ecr\":1}.items()), dict(qc_copy.count_ops().items())))\n        qc = qc.compose(self.generated_circuit, qubits=[0,1])\n        qc = qc.remove_final_measurements()\n        qc.measureall()\n        result = run_circuit(qc)\n        self.assertTrue(result.keys()=={\"00\",\"11\"})\n\nsuite = unittest.TestLoader().loadTestsFromTestCase(TestKLDivergence)\ntest_result = unittest.TestResult()\nsuite.run(test_result)\nissues = test_result.failures + test_result.errors\nif test_result.failures or test_result.errors:\n    raise AssertionError(issues)"}
